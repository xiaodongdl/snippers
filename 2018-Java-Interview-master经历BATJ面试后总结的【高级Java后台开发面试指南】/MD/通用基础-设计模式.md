## 单例模式
[http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)

1. 懒汉（线程不安全，懒加载）：如果没有实例就创建并返回，会有线程安全问题，简单加synchronized解决，但效率不高，升级版本是DCL
2. 懒汉的升级DCL（线程安全，懒加载）：加两个if是因为可能会有多个线程一起进入同步块外的if，如果在同步块内不进行二次检验的话就会生成多个实例了；`instance = new Singleton()`这句会有重排序的问题，用`volidate`解决
3. 饿汉（线程安全，非懒加载）：利用类加载器保证线程安全，但不是懒加载
4. 饿汉升级静态内部类（线程安全，懒加载）：在饿汉的基础上使用静态内部类解决非懒加载问题
5. 枚举（线程安全，非懒加载）：写法最简单，防止反序列化，但不是懒加载  
一般情况下直接使用饿汉式就好了，如果明确要求要懒加载会倾向于使用静态内部类，如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。

## 装饰器模式
在保持原有功能接口不变的基础上动态扩展功能的模式。  
Java IO包中就使用了该模式，InputStream有太多的实现类如FileInputStream，如果要在每个实现类上加上几种功能如缓冲区读写功能Buffered，则会导致出现ileInputStreamBuffered, StringInputStreamBuffered等等，如果还要加个按行读写的功能，类会更多，代码重复度也太高，你说改原来的接口也行啊，但是这样就是改变接口的内容了，现在我想做到不更改以前的功能，动态地增强原有接口。  
所以使用FilterInputStream这个抽象装饰器来装饰InputStream，使得我们可以用BufferedInputStream来包装FileInputStream得到特定增强版InputStream，且增加装饰器种类也会更加灵活。

缺点在于会引入很多小类，从而增加使用复杂度，多层装饰的时候很容易导致不知道如何使用

![](https://github.com/xbox1994/2018-Java-Interview/raw/master/images/j9.png)


欢迎光临[91Code](http://www.91code.info/?utm_source=github&utm_medium=github)，发现更多技术资源~
